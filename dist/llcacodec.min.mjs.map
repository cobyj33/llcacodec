{
  "version": 3,
  "sources": ["../src/formats/rule/ruleData.ts", "../src/formats/rule/bs.ts", "../src/formats/rule/sb.ts", "../src/formats/rule/int.ts", "../src/core/set2D.ts", "../src/core/util.ts", "../src/formats/rule/index.ts", "../src/formats/file/life106.ts", "../src/core/strRead.ts", "../src/formats/file/plaintext.ts", "../src/formats/file/rle.ts", "../src/formats/file/life105.ts", "../src/formats/file/index.ts", "../src/api.ts"],
  "sourcesContent": ["\nexport const CONWAY_LIFE_RULE_DATA = () => ({ birth: [3], survival: [2, 3]})\nexport type LifeRuleData = { birth: number[], survival: number[] }\n\n\nexport function getLifeRuleDataError({ birth, survival }: LifeRuleData): string | \"\" {\n    if (survival.some(num => num < 0 || num > 8)) {\n        return \"Survival neighborhood rules must be between 0 and 8\";\n    }\n    if (birth.some(num => num < 0 || num > 8)) {\n        return \"Birth neighborhood rules must be between 0 and 8\";\n    }\n\n    if (survival.some(num => isNaN(num))) {\n        return \"Survival neighborhood rules cannot contain NaN\";\n    }\n    if (birth.some(num => isNaN(num))) {\n        return \"Birth neighborhood rules cannot contain NaN\";\n    }\n\n    if (survival.some(num => !Number.isInteger(num))) {\n        return \"Survival neighborhood rules must be integer values\";\n    }\n    if (birth.some(num => !Number.isInteger(num))) {\n        return \"Birth neighborhood rules must be integer values\";\n    }\n\n    if (survival.length > 8) {\n        return \"Can only have 8 maximum survival rules\";\n    }\n    if (birth.length > 8) {\n        return \"Can only have 8 maximum birth rules\";\n    }\n\n    if (survival.length !== new Set<number>(survival).size) {\n        return \"Not all survival rules are unique\";\n    }\n    if (birth.length !== new Set<number>(birth).size) {\n        return \"Not all birth rules are unique\";\n    }\n\n    return \"\";\n}\n\nexport function isLifeRuleDataType(obj: unknown): obj is LifeRuleData {\n    return typeof(obj) === \"object\" && obj !== null && \"birth\" in obj && \"survival\" in obj && Array.isArray(obj.birth) && Array.isArray(obj.survival)\n}\n\n/**\n * \n * The validity of a LifeRuleData object is given\n * \n * @param lifeRuleData The LifeRuleData object to validate\n * @returns Whether the provided LifeRuleData object is valid\n */\nexport function isValidLifeRuleData(lifeRuleData: LifeRuleData): boolean {\n    return getLifeRuleDataError(lifeRuleData) === \"\"\n}", "import { LifeRuleData, getLifeRuleDataError, isValidLifeRuleData } from \"../rule/ruleData\";\n\nexport const CONWAY_RULE_STRING_BS = \"B3/S23\"\nexport type BSStringNotation = \"b/s\"\n\n\n/**\n * \n * @param lifeString The B/S notation life rule to test for errors\n * \n * @note These errors are very much not guaranteed to remain the same over releases. However, this function will always return an empty string when given a life rule without errors.\n * @returns An error describing problems with the B/S notation lifeString, or an empty string if the lifeString has no errors\n */\nexport function getBSLifeStringError(lifeString: string): string | \"\" {\n    const sides = lifeString.split(\"/\");\n    if (sides.length < 2) {\n        return `Not able to split string into birth and survival counts, format must include a forward slash (B/S Notation: B<NUMS>/S<NUMS>) (got: ${lifeString})`\n    } \n    if (sides.length > 2) {\n        return `Not able to split string into birth and survival counts, format must include a forward slash (b/s Notation: B<NUMS>/S<NUMS>) (got: ${lifeString})`\n    }\n\n    if (sides[0].charAt(0).toLowerCase() !== \"b\" || sides[1].charAt(0).toLowerCase() !== \"s\") {\n       return `B and S not declared correctly, please switch to B<NUMS>/S<NUMS>  (b/s Notation: B<NUMS>/S<NUMS>) (got: ${lifeString})`\n    }\n\n    const birthNums = sides[0].substring(1).split('').map(numChar => Number.parseInt(numChar))\n    const survivalNums = sides[1].substring(1).split('').map(numChar => Number.parseInt(numChar))\n    \n    if (birthNums.some(num => isNaN(num)) || survivalNums.some(num => isNaN(num))) {\n       return `Must include numbers after B and after /S B<NUMS>/S<NUMS>. Found NaN (b/s Notation: B<NUMS>/S<NUMS>) (got: ${lifeString})`\n    }\n\n    if (birthNums.some(num => num < 0 || num > 8) || survivalNums.some(num => num < 0 || num > 8)) {\n        return `All rule numbers must lie in the range 0 <= num <= 8 (b/s Notation: B<NUMS>/S<NUMS>) (got: ${lifeString})`\n     }\n    \n    if (new Set<number>(birthNums).size !== birthNums.length || new Set<number>(survivalNums).size !== survivalNums.length) {\n       return `Replicate number on one side of B<NUMS>/S<NUMS>. All numbers must be unique (b/s Notation: B<NUMS>/S<NUMS>) (got: ${lifeString})`\n    }\n\n    return \"\";\n}\n\nexport function isValidBSLifeString(lifeString: string) {\n    return getBSLifeStringError(lifeString) === \"\"\n}\n\nexport function makeBSLifeString(lifeRuleData: LifeRuleData): string {\n    const {birth, survival} = lifeRuleData\n    if (isValidLifeRuleData(lifeRuleData)) {\n        return `B${[...birth].sort((a, b) => a - b).join(\"\")}/S${[...survival].sort((a, b) => a - b).join(\"\")}`\n    }\n    \n    throw new Error(`Cannot make new life string from (birth: [${birth}]) and (survival: [${survival}]): ${getLifeRuleDataError(lifeRuleData)}`);\n}\n\nexport function readBSRuleString(lifeString: string): LifeRuleData {\n    if (isValidBSLifeString(lifeString)) {\n        let lifeData: LifeRuleData = {birth: [], survival: []};\n        const [ birth, survival ] = lifeString.split(\"/\");\n         \n         for (let i = 1; i < birth.length; i++) {\n             const num: number = Number.parseInt(birth.charAt(i));\n             lifeData.birth.push(num);\n         }\n     \n     \n         for (let i = 1; i < survival.length; i++) {\n             const num: number = Number.parseInt(survival.charAt(i));\n             lifeData.survival.push(num);\n         }\n     \n         return lifeData;\n    } \n    throw new Error(\"\")\n\n}", "import { LifeRuleData, getLifeRuleDataError, isValidLifeRuleData } from \"./ruleData\";\n\nexport const CONWAY_RULE_STRING_SB = \"23/3\"\nexport type SBStringNotation = \"s/b\"\n\n\nexport function getSBLifeStringError(lifeString: string): string | \"\" {\n    const sides = lifeString.split(\"/\");\n    if (sides.length !== 2) {\n        return `Not able to split s/b life-like rule string into birth and survival counts, format must include a forward slash <Survival Digits>/<Birth Digits> (got: ${lifeString})`\n    }\n\n    const survivalNums: number[] = []\n    const birthNums: number[] = []\n\n    if (sides[0].length > 0) {\n        if (sides[0][0].toUpperCase() === \"S\") {\n            survivalNums.push(...sides[0].substring(1).split('').map(numChar => Number.parseInt(numChar)))\n        } else {\n            survivalNums.push(...sides[0].split('').map(numChar => Number.parseInt(numChar)))\n        }\n    }\n\n    if (sides[1].length > 0) {\n        if (sides[1][0].toUpperCase() === \"B\") {\n            birthNums.push(...sides[1].substring(1).split('').map(numChar => Number.parseInt(numChar)))\n        } else {\n            birthNums.push(...sides[1].split('').map(numChar => Number.parseInt(numChar)))\n        }\n    }\n\n    if (survivalNums.some(num => isNaN(num)) || birthNums.some(num => isNaN(num))) {\n       return `Must include only numbers before and after the slash \"/\" in S/B notation (<Survival Digits>/<Birth Digits>) (got: ${lifeString})`\n    } else if (survivalNums.some(num => num === 9) || birthNums.some(num => num === 9)) {\n        return `9 is an invalid input for s/b notation string (got: ${lifeString})`\n    } else if (new Set<number>(survivalNums).size !== survivalNums.length || new Set<number>(birthNums).size !== birthNums.length) {\n       return `Replicate number on side of <Survival Digits>/<Birth Digits> (got ${lifeString})`\n    }\n    return \"\";\n}\n\nexport function isValidSBLifeString(lifeString: string): boolean {\n    return getSBLifeStringError(lifeString) === \"\"\n}\n\nexport function makeSBLifeString(lifeRuleData: LifeRuleData): string {\n    const { birth, survival } = lifeRuleData\n    if (isValidLifeRuleData(lifeRuleData)) {\n        return `${[...survival].sort((a, b) => a - b).map(num => num.toString()).join(\"\")}/${[...birth].sort((a, b) => a - b).map(num => num.toString()).join(\"\")}`\n    }\n    throw new Error(`[makeSBLifeString] Error while creating lifeString from (${JSON.stringify(lifeRuleData)}), ${getLifeRuleDataError(lifeRuleData)}`)\n}\n\nexport function readSBRuleString(lifeString: string): LifeRuleData {\n    if (isValidSBLifeString(lifeString)) {\n        const sides = lifeString.split(\"/\") as [string, string]\n        return {\n            survival: sides[0].substring(sides[0].length > 0 && sides[0][0].toUpperCase() === \"S\" ? 1 : 0).split(\"\").map(digit => Number.parseInt(digit)),\n            birth: sides[1].substring(sides[1].length > 0 && sides[1][0].toUpperCase() === \"B\" ? 1 : 0).split(\"\").map(digit => Number.parseInt(digit))\n        }\n    }\n    throw new Error(`[readSBRuleString] Error while parsing s/b notation ruleString: ${getSBLifeStringError(lifeString)}`)\n}", "import { LifeRuleData, getLifeRuleDataError, isValidLifeRuleData } from \"./ruleData\";\n\n\nexport const MAX_LIFE_INTEGER = 131071; // 2^17 - 1\nexport const CONWAY_LIFE_RULE_INTEGER = 6152\n\nfunction getLifeRuleIntegerError(lifeInteger: number): string | \"\" {\n    if (!Number.isInteger(lifeInteger)) {\n        return \"Life integer is not an integer value\"\n    }\n    if (lifeInteger > MAX_LIFE_INTEGER) {\n        return `Life integer is an integer greater than maximum value of 2^16 - 1 (${MAX_LIFE_INTEGER})`\n    }\n    if (lifeInteger < 0) {\n        return \"Life integer is an integer less than 0\"\n    }\n\n    return \"\"\n}\n\nexport function isValidLifeRuleInteger(lifeInteger: number) {\n    return getLifeRuleIntegerError(lifeInteger) === \"\"\n}\n\nexport function readLifeRuleInteger(lifeInteger: number): LifeRuleData {\n    if (isValidLifeRuleInteger(lifeInteger)) {\n        const birthRules = lifeInteger & 0xff\n        const survivalRules = (lifeInteger & 0xff00) >> 9\n        const lifeRuleData: LifeRuleData = { birth: [], survival: [] }\n\n        for (let i = 0; i <= 8; i++) {\n            if (birthRules & 1 << i) {\n                lifeRuleData.birth.push(i)\n            }\n            if (survivalRules & 1 << i) {\n                lifeRuleData.survival.push(i);\n            }\n        }\n\n        return lifeRuleData\n    }\n    throw new Error(`Could not read life rule integer: ${getLifeRuleIntegerError(lifeInteger)}`)\n}\n\nexport function makeLifeRuleInteger(lifeRuleData: LifeRuleData): number {\n    const BIRTH_OFFSET = 0;\n    const SURVIVAL_OFFSET = 9;\n    if (isValidLifeRuleData(lifeRuleData)) {\n        let rule = 0;\n        const { birth, survival } = lifeRuleData\n\n        birth.forEach(ruleVal => {\n            rule |= 1 << (ruleVal + BIRTH_OFFSET)\n        })\n\n        survival.forEach(ruleVal => {\n            rule |= 1 << (ruleVal + SURVIVAL_OFFSET)\n        })\n\n        return rule;\n    }\n\n    throw new Error(`Could not make life rule integer from ${JSON.stringify(lifeRuleData)}: ${getLifeRuleDataError(lifeRuleData)}`)\n}", "/**\n * @author Jacoby Johnson \n * @file src/common/Set2D.ts\n * @package jsutil\n * @github https://www.github.com/cobyj33/jsutil\n * @description A Set implementation to hold a unique set of 2D vector\n * values that can easily be queried for existence and iterated over\n * @version 0.1.0\n * @date 2023-4-09\n */\n\n/**\n * A Set implementation to quickly and reliably hold a unique set of 2D vector\n * values that can easily be queried for existence and iterated over\n */\nexport class Set2D {\n    /**\n     * @brief This map internally holds all of the data to query into the Set2D. \n     * \n     * @summary It consists of a key which represents the first component of a 2-dimensional vector,\n     * with a set of number values which represent any second component values associated with the given first component\n     */\n    private map: Map<number, Set<number>> = new Map<number, Set<number>>();\n\n    /**\n     * @brief the internally tracked length of the set. Perhaps \"size\" would have been a better name, but we are stuck with \n     * length for now until the next major version bump.\n     */\n    private _length: number;\n\n    constructor(values: Array<[number, number]> | Set2D = []) {\n        this._length = 0;\n        values.forEach(value => this.add(value[0], value[1])); \n    }\n    \n    /**\n     * Clear all data within this Set2D instance.\n     * \n     * @param total An optional parameter on whether to totally clear the allocated internal data\n     * structures used in the Set2D or not. Defaults to false. Note that whether this \"total\" parameter\n     * is false or true does not affect this function's purpose: This function will always remove all 2D\n     * vectors present in this Set2D instance. However, users can choose whether to reallocate storage containers\n     * within the Set2D instance with the \"total\" parameter\n     */\n    clear(total: boolean = false): void {\n        if (total) {\n            this.map = new Map();\n        } else {\n            [...this.map.values()].forEach(set => set.clear())\n        }\n        this._length = 0;\n    }\n\n    /**\n     * @brief The number of unique 2D vectors stored in this Set2D instance\n     * This number cannot be set by the user. It is instead changed by the\n     * Set2D class internally among additions and removals.\n     */\n    get length(): number { return this._length } \n\n    /**\n     * @returns An array of 2D tuples in the form {[number, number]} of the unique\n     * 2D vectors present in this Set2D instance\n     */\n    getTuples(): Array<[number, number]> {\n        const arr = new Array<[number, number]>(this.length)\n        let i = 0;\n        this.forEach((pair) => {\n            arr[i] = pair\n            i++;\n        })\n\n        return arr\n    }\n\n    /**\n     * Perform a callback function for every vector present in t\n     * \n     * @note The ordering of the calls to the forEach function should not be assumed and is not\n     * guaranteed to stay the same between different versions of jsutil.\n     * \n     * @param callbackfn The callback function to be performed on each 2D vector in this Set2D instance. The\n     * callback function will be passed a 2D vector in the form of {[number, number]}.\n     */\n    forEach(callbackfn: (curr: [number, number]) => void) {\n        this.map.forEach((set, first) => set.forEach(second => callbackfn([first, second])   ))\n    }\n    \n    /**\n     * Add a 2D vector to this Set2D instance\n     * \n     * If the given 2D vector is already present in this Set2D instance\n     * the vector will NOT be added to the Set2D and the Set2D instance will not change\n     * \n     * @param first The first component of the 2D vector to add\n     * @param second The second component of the 2D vector to add\n     */\n    add(first: number, second: number): void {\n        if (this.map.get(first)?.has(second) === false) {\n            this.map.get(first)?.add(second); \n            this._length += 1;\n        } else if (this.map.has(first) === false) {\n            this.map.set(first, new Set<number>([second]))\n            this._length += 1;\n        }\n\n    }\n\n    /**\n     * Remove a 2D vector to this Set2D instance\n     * \n     * If the given 2D vector is not present in this Set2D instance, then\n     * the Set2D instance will not change and this function will do nothing\n     * \n     * @param first The first component of the 2D vector to remove\n     * @param second The second component of the 2D vector to remove\n     */\n    remove(first: number, second: number): void {\n        let set: Set<number> | undefined\n        if (set = this.map.get(first)) {\n            if (set.has(second)) {\n                set.delete(second)\n                this._length -= 1;\n                if (set.size === 0) { \n                    this.map.delete(first)\n                }\n            }\n        }\n    }\n\n    /**\n     * Check whether this Set2D instance contains a given 2D vector.\n     * \n     * @param first The first component of the 2D Vector to check\n     * @param second The second component of the 2D Vector to check\n     * @returns Whether the given 2D vector is present in this Set2D instance\n     */\n    has(first: number, second: number): boolean {\n        return this.map.get(first)?.has(second) || false;\n    }\n\n    /**\n     * Check whether this Set2D instance contains all of the given 2D vectors in a list.\n     * \n     * @param tuples The 2D vectors to check for existence in this Set2D instance\n     * @returns Whether all given 2D vectos are present in this Set2D instance\n     */\n    hasAll(tuples: Array<[number, number]>): boolean {\n        return tuples.every(tuple => this.has(tuple[0], tuple[1]));\n    }\n\n    /**\n     * Check whether this Set2D instance contains all and ONLY all of the given 2D vectors in a list.\n     * \n     * @param tuples The 2D vectors to check for existence in this Set2D instance\n     * @returns Whether all given 2D vectos are present in this Set2D instance, \n     */\n    hasAllExact(tuples: Array<[number, number]>): boolean {\n        return tuples.length === this.length && this.hasAll(tuples);\n    }\n\n    /**\n     * Combine this Set2D with other Set2D's and/or 2D vector arrays\n     * \n     * Similar to the concat function in Javascript Arrays\n     * \n     * Note that this Set2D instance will NOT be modified by the \"combine\" function. In order to push 2D vector data and\n     * modify this Set2D instance in-place, use the \"push\" function. \n     * \n     * @param others Variable arguments. Other Set2D's or 2D vector arrays\n     * @returns A new Set2D instance created by combining 2D vectors present in this Set2D instance,\n     * given Set2D instances, and given 2D vector arrays\n     */\n    combine(...others: (Set2D | [number, number])[]): Set2D {\n        const set = new Set2D();\n        set.push(this, ...others);\n        return set;\n    }\n\n    /**\n     * Push 2D vector values into this Set2D instance\n     * \n     * Similar to the push function in Javascript Arrays\n     * \n     * Note that this Set2D instance will be modified by pushing data. In order to create a new Set2D instance\n     * with combined data without modifying this Set2D instance in-place, use the \"combine\" function. \n     * \n     * @param others Variable argument parameter, where other Set2D's or arrays of 2D vectors can be pushed into this Set2D instance.\n     * Each given vector is added to this Set2D instance.\n     */\n    push(...others: (Set2D | [number, number])[]): void {\n        others.forEach(other => Array.isArray(other) ? this.add(other[0], other[1]) : other.forEach(tuple => this.add(tuple[0], tuple[1])) );\n    }\n\n    /**\n     * Iterator integration for \"for ... of \" syntax\n     */\n    *[Symbol.iterator](): IterableIterator<[number, number]> {\n        for (const pair of this.map) {\n            for (const second of pair[1]) {\n                yield [pair[0], second]\n            }\n        }\n    }\n\n    /**\n     * Check whether 2 Set2D instances are equal\n     * \n     * 2 Set2D instances are considered \"equal\" if they have the same stored vectors present within\n     * \n     * @param other The other Set2D instance to check equality with\n     * @returns Whether the two Set2D instances are equal according to the stated conditions.\n     */\n    equals(other: Set2D): boolean {\n        if (this.length !== other.length) {\n            return false;\n        }\n        \n        for ( const entry of this ) {\n            if (other.has(entry[0], entry[1]) === false) {\n                return false;\n            }\n        }\n        return true;\n    }\n}", "import { Set2D } from \"./set2D\";\n\n\n/**\n * Test if a matrix is rectangular or not\n * \n * A matrix is considered rectangular if it's height is not 0, and all rows have the same amount of columns\n * \n * @param matrix A matrix of a data type\n * @returns If the matrix is rectangular or not\n */\nexport function isRectangularMatrix(matrix: unknown[][]): boolean {\n    if (matrix.length === 0) return true;\n    const width = matrix[0].length;\n\n    for (let row = 0; row < matrix.length; row++) {\n        if (matrix[row].length !== width) return false;\n    }\n    return true;\n}\n\n/**\n * Check whether a function throws an error when called\n * \n * @param action The function to envoke to check if it throws an error\n * @returns Whether the function throws an error upon invokation\n */\nexport function throws(action: () => unknown): boolean {\n    try {\n        action();\n        return false;\n    } catch (e) {\n        return true;\n    }\n}\n\nconst DIGIT_DECIMAL_CHARACTERS = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"] as const\nconst DIGIT_BINARY_CHARACTERS = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"] as const\nconst DIGIT_HEX_CHARACTERS = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\"] as const\n\nconst ASCII_CHAR_CODE_0 = 48;\nconst ASCII_CHAR_CODE_9 = 57;\n\nexport function isDigit(digit: string): boolean {\n    return digit.length === 1 && digit.charCodeAt(0) >= ASCII_CHAR_CODE_0 && digit.charCodeAt(0) <= ASCII_CHAR_CODE_9\n} \n\n// An unnecessarily complicated problem in Javascript: https://stackoverflow.com/questions/175739/how-can-i-check-if-a-string-is-a-valid-number \nexport const isNumericString = (num: string) => num.trim() !== '' && !isNaN(num as unknown as number);\n\n\nexport function trimTrailing(s: string, charToTrim: string) {\n    if (charToTrim.length !== 1) {\n        throw new Error(\"\")\n    }\n\n    const regExp = new RegExp(charToTrim + \"+$\");\n    const result = s.replace(regExp, \"\");\n\n    return result;\n}\n\nexport function isIntegerString(num: string): boolean {\n    for (let i = 0; i < num.length; i++) {\n        if (i === 0) {\n            if (!isDigit(num[i]) && num[i] !== \"-\") {\n                return false;\n            }\n        } else {\n            if (!isDigit(num[i])) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nexport function isNumberPairArray(arr: unknown): arr is [number, number][] {\n    return Array.isArray(arr) && arr.every(row => Array.isArray(row) && row.length === 2)\n}\n\nexport function isCellMatrix(arr: unknown): arr is (0 | 1)[][] {\n    return Array.isArray(arr) && arr.every(row => Array.isArray(row) && row.every(cell => cell === 0 || cell === 1))\n}\n\nexport function isCellCoordinateArray(arr: unknown): arr is [number, number][] {\n    return Array.isArray(arr) && arr.every(row => Array.isArray(row) && row.length === 2 && row.every(component => Number.isInteger(component)))\n}\n\nexport function isStringArray(arr: unknown): arr is string[] {\n    return Array.isArray(arr) && arr.every(val => typeof(val) === \"string\")\n}\n\ntype Bounds = { x: number, y: number, width: number, height: number  }\n\n/**\n * \n * @param positions \n * @returns Bounds object (maxY is given with the basis that positive is up)\n */\nexport function getCellBoundingBox(positions: [number, number][]): Bounds {\n    if (positions.length === 0) {\n        throw new Error(\"Cannot create bounding box over empty area\");\n    }\n\n    let minY = positions[0][1];\n    let maxY = positions[0][1];\n    let minX = positions[0][0];\n    let maxX = positions[0][0];\n\n    for (let i = 0; i < positions.length; i++) {\n        minY = Math.min(minY, positions[i][1])\n        minX = Math.min(minX, positions[i][0])\n        maxY = Math.max(maxY, positions[i][1])\n        maxX = Math.max(maxX, positions[i][0])\n    }\n\n    return { x: minX, y: maxY, width: Math.abs(maxX - minX) + 1, height: Math.abs(maxY - minY) + 1 }\n}\n\nexport function numberPairArrayToMatrix(positions: [number, number][]): (0 | 1)[][] {\n    if (positions.length === 0) {\n        return [];\n    }\n\n    const bounds = getCellBoundingBox(positions);\n    const matrix: (0 | 1)[][] = Array.from({ length: bounds.height }, () => new Array<0>(bounds.width).fill(0));\n    positions.forEach(position => {\n        matrix[bounds.y - position[1]][position[0] - bounds.x] = 1;\n    })\n    return matrix;\n}\n\nexport function matrixToNumberPairArray(matrix: (0 | 1)[][]): [number, number][] {\n    const output: [number, number][] = []\n    for (let row = 0; row < matrix.length; row++) {\n        for (let col = 0; col < matrix[row].length; col++) {\n            if (matrix[row][col] === 1) {\n                output.push([col, -row])\n            }\n        }\n    }\n\n    return output;\n}\n\nexport function isError(e: any): e is Error {\n    return typeof(e) === \"object\" && e !== null && \"stack\" in e && typeof(e.stack) === 'string' && \"message\" in e && typeof(e.message) === 'string';\n}\n\nexport function getErrorMessage(e: any): string {\n    if (isError(e)) {\n        return e.message;\n    } else if (typeof(e) === \"string\") {\n        return e;\n    } else {\n        if (\"toString\" in e) {\n            return e.toString();\n        }\n    }\n    return \"\"\n}\n\nexport function reverseBits(num: number): number {\n    let o = 0;\n    for (let i = 0; i < 32; i++) {\n        o |= (num & 1 << (31 - i)) > 0 ? 1 << i : 0;\n    }  \n    return o;\n}\n\n/**\n * Determines if two arrays are strictly the same\n * \n * Number arrays are considered the same if they have the same length and every data point at every index is the same\n * \n * @param first A number array\n * @param second Another number array\n * @returns Whether the two number arrays are considered equal according to the described conditions\n */\nexport function isStrictEqualArray(first: any[], second: any[]): boolean {\n    if (first.length !== second.length) {\n        return false;\n    }\n    const length = first.length\n\n    for (let i = 0; i < length; i++) {\n        if (first[i] !== second[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nexport const isStrictEqualNumberArray: (first: number[], second: number[]) => boolean = (first, second) => isStrictEqualArray(first, second)\nexport const isStrictEqualStringArray: (first: string[], second: string[]) => boolean = (first, second) => isStrictEqualArray(first, second)\nexport const isStrictEqualBooleanArray: (first: boolean[], second: boolean[]) => boolean = (first, second) => isStrictEqualArray(first, second)\n\nexport function uniqueNumberPairArray(arr: [number, number][]) {\n    const set2D = new Set2D()\n    const output: [number, number][] = []\n    for (let i = 0; i < arr.length; i++) {\n        if (set2D.has(arr[i][0], arr[i][1])) {\n            continue;\n        }\n        output.push([...arr[i]])\n\n        set2D.add(arr[i][0], arr[i][1])\n    }\n    \n    return output;\n}", "import { CONWAY_RULE_STRING_BS, isValidBSLifeString, makeBSLifeString, readBSRuleString } from \"./bs\";\nimport { CONWAY_RULE_STRING_SB, isValidSBLifeString, makeSBLifeString, readSBRuleString } from \"./sb\";\nimport { CONWAY_LIFE_RULE_INTEGER, isValidLifeRuleInteger, makeLifeRuleInteger, readLifeRuleInteger } from \"./int\"\nimport { CONWAY_LIFE_RULE_DATA, LifeRuleData, isValidLifeRuleData } from \"./ruleData\";\nimport { getErrorMessage } from \"../../core/util\";\n\nexport { CONWAY_LIFE_RULE_DATA, CONWAY_RULE_STRING_BS, CONWAY_RULE_STRING_SB, CONWAY_LIFE_RULE_INTEGER, LifeRuleData, isValidLifeRuleData }\n\nexport type LifeRuleStringNotation = \"b/s\" | \"s/b\" | \"int\"\n\nexport function isValidLifeRule(rule: string, format: \"b/s\"): boolean\nexport function isValidLifeRule(rule: string, format: \"s/b\"): boolean\nexport function isValidLifeRule(rule: number, format: \"int\"): boolean\nexport function isValidLifeRule(rule: string | number): boolean\nexport function isValidLifeRule(rule: string | number, format: LifeRuleStringNotation | \"\" = \"\"): boolean {\n    const foundFormat = format === \"\" ? getLifeRuleFormat(rule) : format\n    if (foundFormat === \"N/A\") {\n        return false;\n    }\n\n    if (typeof(rule) === \"number\") {\n        if (foundFormat !== \"int\") {\n            return false;\n        }\n        return isValidLifeRuleInteger(rule)\n    }\n\n    if (typeof(rule) === \"string\") {\n        switch (foundFormat) {\n            case \"b/s\": return isValidBSLifeString(rule);\n            case \"s/b\": return isValidSBLifeString(rule);\n        }\n    }\n    return false;\n}\n\nexport function getLifeRuleFormat(rule: string | number): LifeRuleStringNotation | \"N/A\" {\n    if (typeof(rule) === \"string\") {\n        if (isValidBSLifeString(rule)) {\n            return \"b/s\";\n        } else if (isValidSBLifeString(rule)) {\n            return \"s/b\"\n        }\n    }\n    else if (typeof(rule) === \"number\") {\n        if (isValidLifeRuleInteger(rule)) {\n            return \"int\"\n        }\n    }\n\n    return \"N/A\"\n}\n\nexport function readLifeRule(rule: string | number, format: LifeRuleStringNotation | \"\" = \"\"): LifeRuleData {\n    const foundFormat = format === \"\" ? getLifeRuleFormat(rule) : format\n    if (foundFormat === \"N/A\") {\n        throw new Error(`Could not parse Life String: ${rule}, could not find a fitting format (Available formats are \"b/s\", \"s/b\", and \"int\"), read at https://conwaylife.com/wiki/Rulestring https://conwaylife.com/wiki/Rule_integer)`);\n    }\n\n    if (typeof(rule) === \"number\") {\n        if (format !== \"int\" && format !== \"\") { // requested a string-based format with an integer value\n            throw new Error(`Could not read rule ${rule} in requested format ${format}, as the integer value ${rule} cannot be in the ${format} string format`)\n        }\n        return readLifeRuleInteger(rule)\n    }\n\n    switch (foundFormat) {\n        case \"b/s\": return readBSRuleString(rule);\n        case \"s/b\": return readSBRuleString(rule);\n    }\n    \n    throw new Error(`Could not parse Life String: ${rule}, could not find a fitting format (Available formats are \"b/s\", \"s/b\", and \"int\"), read at https://conwaylife.com/wiki/Rulestring https://conwaylife.com/wiki/Rule_integer)`);\n}\n\nexport function makeLifeRule(lifeRuleData: LifeRuleData, format: \"b/s\"): string\nexport function makeLifeRule(lifeRuleData: LifeRuleData, format: \"s/b\"): string\nexport function makeLifeRule(lifeRuleData: LifeRuleData, format: \"int\"): number\nexport function makeLifeRule(lifeRuleData: LifeRuleData, format: LifeRuleStringNotation): string | number\nexport function makeLifeRule(lifeRuleData: LifeRuleData, format: LifeRuleStringNotation): string | number {\n    try {\n        switch (format) {\n            case \"b/s\": return makeBSLifeString(lifeRuleData)\n            case \"s/b\": return makeSBLifeString(lifeRuleData)\n            case \"int\": return makeLifeRuleInteger(lifeRuleData)\n        }\n    } catch (e) {\n        throw new Error(`Could not make life rule string from life rule data object: (${JSON.stringify(lifeRuleData)}) : ${getErrorMessage(e)}`)\n    }\n}\n\nexport function convertLifeRule(original: string | number, dstFormat: \"b/s\"): string\nexport function convertLifeRule(original: string | number, dstFormat: \"s/b\"): string\nexport function convertLifeRule(original: string | number, dstFormat: \"int\"): number\nexport function convertLifeRule(original: string | number, dstFormat: LifeRuleStringNotation): string | number {\n    const lifeRuleData = readLifeRule(original);\n    return makeLifeRule(lifeRuleData, dstFormat);\n}\n\nexport default {\n    isValidLifeRule,\n    getLifeRuleFormat,\n    readLifeRule,\n    makeLifeRule,\n    convertLifeRule\n}", "import { isIntegerString } from \"../../core/util\";\nimport { Set2D } from \"../../core/set2D\"\n\nconst LIFE_106_HEADER = \"#Life 1.06\" as const\nconst LIFE_106_FILE_EXTENSIONS = [\".lif\", \".life\"] as const\n\nexport function isLife106String(str: string): boolean {\n    return str.trim().startsWith(LIFE_106_HEADER)\n}\n\nexport interface Life106DecodedData {\n    format: \"life 1.06\"\n    liveCoordinates: [number, number][]\n}\n\nexport interface Life106EncodingData {\n    liveCoordinates: [number, number][]\n}\n\n// --------------------------------------------------------------\n// --------------------------------------------------------------\n// --------------------------------------------------------------\n// ------------------------- WRITING ----------------------------\n// --------------------------------------------------------------\n// --------------------------------------------------------------\n// --------------------------------------------------------------\n\nexport function writeLife106String(data: Life106EncodingData): string {\n    const builder: string[] = []\n    builder.push(LIFE_106_HEADER + \"\\n\")\n    const dupSet: Set2D = new Set2D();\n\n    for (let i = 0; i < data.liveCoordinates.length; i++) {\n        const [x, y] = data.liveCoordinates[i];\n        if (dupSet.has(x, y)) {\n            continue;\n        }\n\n        builder.push(`${x} ${y}\\n`)\n        dupSet.add(x, y)\n    }\n\n    return builder.join(\"\")\n}\n\n// --------------------------------------------------------------\n// --------------------------------------------------------------\n// --------------------------------------------------------------\n// ------------------------- READING ----------------------------\n// --------------------------------------------------------------\n// --------------------------------------------------------------\n// --------------------------------------------------------------\n\n\nexport function readLife106String(str: string): Life106DecodedData {\n    if (!str.trim().startsWith(LIFE_106_HEADER)) {\n        throw new Error(`Could not read Life 1.06 string. Error at Line 1: does not begin with appropriate header. Must be \"${LIFE_106_HEADER}\" ${str}`)\n    }\n\n    const output: [number, number][] = []\n    const set2D: Set2D = new Set2D()\n    const lines = str.split(\"\\n\")\n    let ended: boolean = false;\n\n    for (let i = 1; i < lines.length; i++) {\n        const nums = lines[i].trim().split(\" \").filter(val => val.length > 0)\n        if (nums.length !== 2) {\n            if (nums.length === 0) { // Check if there are any extra lines at the end. This is true if there is no input or if all input is empty strings\n                ended = true;\n                continue;\n            }\n            throw new Error(`Invalid Life 1.06 string. Error at Line ${i}. There must be an X and a Y position only on subsequent lines after the Life 1.06 Header \\n${str}\\n `)\n        }\n\n        if (ended) {\n            throw new Error(`Invalid Life 1.06 string: \\n${str}\\n Error at Line ${i}. X and Y Values must be on subsequent lines`)\n        }\n\n        if (isIntegerString(nums[0]) && isIntegerString(nums[1])) {\n            const [x, y] = [Number.parseInt(nums[0]), Number.parseInt(nums[1])]\n            if (!set2D.has(x, y)) {\n                set2D.add(x, y)\n                output.push([x, y])\n            }\n        } else {\n            throw new Error(`Invalid Life 1.06 string. Error at Line ${i}. Cell positions must be integers ( got ${nums[0]} and ${nums[1]}) \\n${str}\\n `)\n        }\n    }\n\n    return {\n        format: \"life 1.06\",\n        liveCoordinates: output\n    };\n}", "\n/**\n * @file src/core/strRead.ts\n * @author Jacoby Johnson\n * @brief An abstraction to read tokens and patterns incrementally from a string\n * \n * Inspired from Java Scanner and C++ std::stringstream\n * \n * @note These functions were made just for llcacodec, so if there are any weird design decisions and a lot of thrown errors, that's why.\n * I wanted to write the functions in such a way that if I didn't account for any edge cases then I would break the library. It forces me to \n * think about every edge case and that's honestly how I want it to be. Also, if a file fails to parse, it simply throws a corresponding error\n */\n\nimport { isDigit, isNumericString } from \"./util\";\n\n/**\n * @brief Checks if the next non white-space character from the string matches the given character\n * \n * If a char is specified, the next non white-space character must be that character or else an error is thrown\n * \n * @param data The string to read a character from\n * @param char A character to read. This string must have a length of 1 and must NOT be whitespace \n * @returns {boolean} If the next character in the given data string matches the provided character\n */\nexport function isNextChar(data: string, char: string): boolean {\n    if (char.length !== 1) {\n        throw new Error(`[llcacodec::isNextChar Cannot query for next ${char.length} length character. Character must have a length of 1`)\n    } \n    if (char === \" \") {\n        throw new Error(`[llcacodec::isNextChar Cannot query for next whitespace character`) \n    }\n\n    let index = 0;\n    while (index < data.length) {\n        if (data[index] !== \" \") {\n            return data[index] === char\n        }\n        index++;\n    }\n    throw new Error(\"\")\n}\n\n/**\n * @brief Reads the next non white-space character from the string\n * \n * @note This function will read special characters line newlines and carriage returns\n * \n * @param data The string to read a character from\n * @returns {[string, string]} where the first value is the read character and the second value is the remaining data string\n * @throws If a character could not be read. IE: The provided data string is only whitespace\n */\nexport function readChar(data: string): [string, string]\n\n/**\n * @brief Reads the next provided character from the string the next non-whitespace character must be that character or else an error is thrown\n * \n * @param data The string to read a character from\n * @param char The character to read. This character must have a length of either 0 or 1 and must **NOT** be a whitespace character.\n * If no character is given, readChar will simply read the next non-whitespace character\n * @returns {[string, string]} where the first value is the read character and the second value is the remaining data string\n * @throws If the provided char does not have a length of 1, If the provided char is a whitespace character, or if the character could not be read\n */\nexport function readChar(data: string, char: string): [string, string]\nexport function readChar(data: string, char: string = \"\"): [string, string] {\n    if (char.length > 1) {\n        throw new Error(`[llcacodec::readChar Cannot read next ${char.length} length character. Character must have a length of 1]`)\n    } \n    if (char === \" \") {\n        throw new Error(`[llcacodec::readChar Cannot read whitespace character]`) \n    } \n    if (char === undefined) {\n        throw new Error(`[llcacodec::readChar Cannot read undefined]`) \n    }\n\n    let index = 0;\n    while (index < data.length) {\n        if (data[index] !== \" \") {\n            if (char !== \"\" && char !== data[index]) {\n                throw new Error(`[llcacodec::readChar Failed to read next character as ${char}, got ${data[index]}]`)\n            }\n            return [data[index], index + 1 < data.length ? data.substring(index + 1) : \"\"]\n        }\n        index++;\n    }\n    throw new Error(\"[strRead::readChar] Reached end of string and could not read any next characters\")\n}\n\n\n/**\n * @brief read characters from a data string\n * \n * @param data the data string to read from\n * @param count The number of characters to read from the string\n * @returns {[string[], string]} A tuple, where the first entry is the returned read characters and the second entry is the remaining string after reading the characters.\n */\nexport function readChars(data: string, count: number): [string[], string]\n/**\n * @brief read characters from a data string\n * \n * @param data the data string to read from\n * @param charsToRead A string of characters to read from the given data string sequentially\n * @returns {[string[], string]} A tuple, where the first entry is the returned read characters and the second entry is the remaining string after reading the characters. \n * The returned first entry will be an array of the passed in charsToRead\n */\nexport function readChars(data: string, charsToRead: string): [string[], string]\nexport function readChars(data: string, charOrCount: string | number): [string[], string] {\n    if (typeof(charOrCount) === \"string\") {\n        const charsToRead = charOrCount.split(\"\")\n        if (charsToRead.length === 0) {\n            throw new Error(\"Cannot read 0 characters from a string\")\n        }\n\n        let remainingString = data;\n        for (let i = 0; i < charsToRead.length; i++) {\n            const [, afterChar] = readChar(remainingString, charsToRead[i])\n            remainingString = afterChar\n        }\n        return [charsToRead, remainingString]\n    } else if (typeof(charOrCount) === \"number\") {\n        if (!Number.isInteger(charOrCount)) {\n            throw new Error(\"Cannot read a non-integer amount of characters from a string\")\n        } else if (charOrCount < 0) {\n            throw new Error(\"Cannot read a negative amount of characters from a string\")\n        }\n\n        const readChars: string[] = []\n\n        let remainingString = data;\n        for (let i = 0; i < charOrCount; i++) {\n            const [char, afterChar] = readChar(remainingString)\n            remainingString = afterChar\n            readChars.push(char)\n        }\n        return [readChars, remainingString]\n    } else {\n        throw new Error(\"Passed in non-string non-number value to charOrCount of readChars\")\n    }\n}\n\n/**\n * @brief Determine if the next non-whitespace characters available in the data string follow the provided sequence\n * \n * @param data The data string to validate against\n * @param chars The characters\n * @returns {boolean} whether the next non-whitespace characters found in the string follow the provided sequence\n * @throws If any whitespace is passed into the \"chars\" string\n * @throws If the length of the passed in characters is 0\n */\nexport function isNextChars(data: string, chars: string): boolean {\n    if (chars.length === 0) {\n        throw new Error(`[llcacodec::isNextChars Cannot check if next characters in string is empty`)\n    }\n    \n    let dataIndex = 0;\n    let charsIndex = 0;\n    while (dataIndex < data.length && charsIndex < chars.length) {\n        if (chars[charsIndex] === \" \") {\n            throw new Error(`[llcacodec::isNextChars Cannot check if next character in string is whitespace`)\n        }\n        if (data[dataIndex] !== \" \") {\n            if (data[dataIndex] === chars[charsIndex]) {\n                charsIndex++;\n            } else {\n                return false;\n            }\n        }\n        dataIndex++;\n    }\n\n    return charsIndex === chars.length\n}\n\n/**\n * @brief Reads the next line from the string.\n * @note The newline character is not retained in the returned line.\n * @param data The data string to read from\n * @returns {[string, string]} A tuple where the first entry is the line read from the string and the second entry is the remaining data in the data string \n * @throws If the next line in the string is not available (i.e. the data parameter is empty), an error is thrown\n */\nexport function readLine(data: string): [string, string] {\n    if (data.length === 0) {\n        throw new Error(`[llcacodec::readLine] Attempted to read line from an empty string`);\n    }\n\n    let index = 0;\n    while (index < data.length && data[index] !== \"\\n\") {\n        index++;\n    }\n\n    //the value at data[index] is equal to \\n, or it is at the end of the data string\n\n    return [data.substring(0, index > 0 && data[index - 1] === \"\\r\" ? index - 1 : index), index + 1 < data.length ? data.substring(index + 1) : \"\"];\n}\n\n/**\n * @brief Reads the next string of non whitespace characters from the data as a number.\n * @param data The data string to read from\n * @returns {[string, string]} A tuple, where the first entry is the number read from the string and the second entry is the remaining string after reading\n * @throws If the next string of non whitespace characters does not convert to a number\n */\nexport function readNumber(data: string): [number, string] {\n    const [numstr, stream] = readNext(data)\n    if (isNumericString(numstr)) {\n        const num = Number(numstr) \n        if (!isNaN(num)) {\n            return [num, stream];\n        }\n        throw new Error(`[llcacodec::readNumber Number String ${numstr} incorrectly converted to NaN]`)\n    }\n    throw new Error(`[llcacodec::readNumber Number String ${numstr} is not a numerical string]`)\n}\n\n/**\n * @brief Reads the next sequence of non whitespace characters from the data as a float. The number MUST be a float value or else an error is thrown\n * @param data The data string to read from\n * @returns {[string, string]} A tuple, where the first entry is the float read from the string and the second entry is the remaining string after reading\n * @throws If the next string of non whitespace characters does not convert to a number\n * @throws If the next string of non whitespace characters is a number, but is not a float\n */\nexport function readFloat(data: string): [number, string] {\n    const [num, stream] = readNumber(data)\n    if (!Number.isInteger(num)) {\n        return [num, stream]\n    }\n    throw new Error(`[llcacodec::readFloat Cannot read Decimal, as returned number is an Integer value]`)\n}\n\n/**\n * @brief Reads the next sequence of non whitespace characters from the data as a integer. The number MUST be a integer value or else an error is thrown\n * @param data The data string to read from\n * @returns {[string, string]} A tuple, where the first entry is the integer read from the string and the second entry is the remaining string after reading\n * @throws If the next string of non whitespace characters does not convert to a number\n * @throws If the next string of non whitespace characters is a number, but is not an integer\n */\nexport function readInteger(data: string): [number, string] {\n    const [num, stream] = readNumber(data)\n    if (Number.isInteger(num)) {\n        return [num, stream]\n    }\n    throw new Error(`[llcacodec::readInteger Cannot read Decimal, as returned number is a float value]`)\n}\n\n/**\n * @brief Reads the next sequence of non whitespace characters from the data as a positive integer. The number MUST be a positive integer value or else an error is thrown\n * @param data The data string to read from\n * @returns {[string, string]} A tuple, where the first entry is the positive integer read from the string and the second entry is the remaining string after reading\n * @throws If the next string of non whitespace characters does not convert to a number\n * @throws If the next string of non whitespace characters is a number, but is not a positive integer\n */\nexport function readPositiveInteger(data: string): [number, string] {\n    const [num, stream] = readInteger(data)\n    if (num > 0) {\n        return [num, stream]\n    }\n    throw new Error(`[llcacodec::readPositiveInteger Cannot read Positive Integer, as returned integer is less than 0]`)\n}\n\n/**\n * @brief Reads the next sequence of non whitespace characters from the data as a negative integer. The number MUST be a negative integer value or else an error is thrown\n * @param data The data string to read from\n * @returns {[string, string]} A tuple, where the first entry is the negative integer read from the string and the second entry is the remaining string after reading\n * @throws If the next string of non whitespace characters does not convert to a number\n * @throws If the next string of non whitespace characters is a number, but is not a negative integer\n */\nexport function readNegativeInteger(data: string): [number, string] {\n    const [num, stream] = readInteger(data)\n    if (num < 0) {\n        return [num, stream]\n    }\n    throw new Error(`[llcacodec::readNegativeInteger Cannot read Negative Integer, as returned integer is greater than 0]`)\n}\n\nexport function readNumbers(data: string, numOfNums: number): [number[], string] {\n    if (numOfNums < 0) {\n        throw new Error(`Cannot read a negative amount of numbers`)\n    } else if (!Number.isInteger(numOfNums)) {\n        throw new Error(`Cannot read a decimal number of numbers`)\n    }\n    \n    const numbers: number[] = []\n    let remaining = data;\n    for (let i = 0; i < numOfNums; i++) {\n        const [number, afterRead] = readNumber(remaining)\n        numbers.push(number)\n        remaining = afterRead\n    }\n\n    return [numbers, remaining]\n}\n\nexport function readIntegers(data: string, numOfIntegers: number): [number[], string] {\n    const [numbers, stream] = readNumbers(data, numOfIntegers)\n    if (numbers.every(num => Number.isInteger(num))) {\n        return [numbers, stream] \n    }\n    throw new Error(`Cannot read ${numOfIntegers} integers: Found non integer values: ${ numbers.map((num, index) => [index, num] as [number, number]).filter(pair => !Number.isInteger(pair[1])) } `)\n}\n\n/**\n * Reads the next string of any representation of a number, ignoring white-space.\n * Only works with \n * @param data \n * @returns \n */\nexport function readCrampedNumber(data: string): [number, string] {\n    let hitPoint = false;\n    let i = 0;\n\n    let numchars: string[] = []\n\n    while (i < data.length) {\n        const char = data[i]\n        if (char === \" \") {\n\n            if (numchars.length === 0) {\n                i++;\n                continue;\n            } else {\n                break;\n            }\n\n        } else if (char === \"-\") {\n\n            if (numchars.length === 0) {\n                numchars.push(\"-\")\n            } else {\n                break\n            }\n\n        } else if (char === \".\") {\n            \n            if (hitPoint === false) {\n                numchars.push(\".\")\n                hitPoint = true\n            } else {\n                break\n            }\n\n        } else if (isDigit(char)) {\n            numchars.push(char)\n        } else {\n\n            if (numchars.length === 0) {\n                throw new Error(`Could not read cramped number (Encountered invalid char ${char} at index ${i} of string \"${data}\")`)\n            } else {\n                break;\n            }\n\n        }\n\n        i++\n    }\n\n    const numstr = numchars.join(\"\")\n    if (isNumericString(numstr)) {\n        const num = Number(numstr) \n        if (!isNaN(num)) {\n            return [num, i < data.length ? data.substring(i) : \"\"];\n        }\n        throw new Error(`Cramped Number read as NaN (got \"${numstr}\" ) ( passed in: \"${data}\" )`)\n    }\n\n    throw new Error(`Cramped Number not evaluated to numeric string (got ${numstr} ) ( passed in: ${data})`)\n}\n\nexport function readCrampedInteger(data: string): [number, string] {\n    const [num, stream] = readCrampedNumber(data)\n    if (Number.isInteger(num)) {\n        return [num, stream]\n    }\n    throw new Error(\"Cannot read Cramped Integer\")\n}\n\nexport function readCrampedPositiveInteger(data: string): [number, string] {\n    const [num, stream] = readCrampedInteger(data)\n    if (num > 0) {\n        return [num, stream]\n    }\n    throw new Error(\"Cannot read positive cramped integer\")\n}\n\n/**\n * @brief Reads the next sequence of non whitespace characters from the data. \n * If the next string of non whitespace characters cannot be found, an error is thrown\n * @param data The data string to read from\n * @returns {[string, string]} A tuple where the first entry is the next string of non-whitespace characters found in the provided data,\n * and the second entry is the remaining data after reading\n * @throws If the next string of non whitespace characters cannot be found. (IE: The given string is empty or only contains whitespace)\n */\nexport function readNext(data: string): [string, string] {\n    let index = 0;\n    let startIndex = -1;\n    while (index < data.length) {\n\n        if (data[index] === \" \") {\n            if (startIndex === -1) {\n                index++;\n                continue;\n            } else { // note that data[index] is still equal to whitespace\n                return [index > 0 ? data.substring(startIndex, index) : \"\", index < data.length ? data.substring(index) : \"\"];\n            }\n        }\n        \n        if (startIndex === -1) {\n            startIndex = index;\n        }\n        index++;\n    }\n\n    if (startIndex === -1) {\n        throw new Error(`[llcacodec::readNext could not read sequence, no beginning to a non-whitespace sequence could be found (data: ${data})]`);\n    }\n\n    return [data.substring(startIndex, index), index < data.length ? data.substring(index) : \"\"];\n}   ", "import { trimTrailing, numberPairArrayToMatrix, isStringArray, isCellMatrix, isCellCoordinateArray } from \"../../core/util\";\nimport { isNextChar, isNextChars, readChar, readChars } from \"../../core/strRead\"\n\nconst VALID_DEAD_CELL_CHARACTERS = [\".\"] as const;\nconst VALID_LIVE_CELL_CHARACTERS = [\"O\", \"*\"] as const;\n\nexport interface PlaintextDecodedData {\n    format: \"plaintext\"\n    name: string\n    description: string[]\n    matrix: (0 | 1)[][]\n    liveCoordinates: [number, number][]\n}\n\nexport interface PlaintextMatrixEncodingData {\n    name: string,\n    description: string | string[]\n    matrix: (0 | 1)[][]\n}\n\nexport function isPlaintextMatrixEncodingData(data: unknown): data is PlaintextMatrixEncodingData {\n    return typeof(data) === \"object\" && data !== null &&\n    \"name\" in data && \"description\" in data && \"matrix\" in data &&\n    typeof(data.name) === \"string\" && (typeof(data.description) === \"string\" || isStringArray(data.description)) &&\n    isCellMatrix(data.matrix)\n}\n\nexport interface PlaintextCoordinateEncodingData {\n    name: string,\n    description: string | string[]\n    liveCoordinates: [number, number][]\n}\n\nexport function isPlaintextCoordinateEncodingData(data: unknown): data is PlaintextCoordinateEncodingData {\n    return typeof(data) === \"object\" && data !== null &&\n    \"name\" in data && \"description\" in data && \"liveCoordinates\" in data &&\n    typeof(data.name) === \"string\" && (typeof(data.description) === \"string\" || isStringArray(data.description)) &&\n    isCellCoordinateArray(data.liveCoordinates)\n}\n\n// --------------------------------------------------------------\n// --------------------------------------------------------------\n// --------------------------------------------------------------\n// ------------------------- WRITING ----------------------------\n// --------------------------------------------------------------\n// --------------------------------------------------------------\n// --------------------------------------------------------------\n\nexport function writePlaintextString(data: PlaintextMatrixEncodingData | PlaintextCoordinateEncodingData): string {\n    let matrix: (0 | 1)[][] = [];\n    if (\"matrix\" in data) {\n        matrix = data.matrix;\n    } else {\n        for (let i = 0; i < data.liveCoordinates.length; i++) {\n            if (!Number.isInteger(data.liveCoordinates[i][0]) || !Number.isInteger(data.liveCoordinates[i][1])) {\n                throw new Error(`Attempted to write plain text with Invalid Coordinates: Coordinates must all be integers (Error at coordinate #${i} x: ${data.liveCoordinates[i][0]} y: ${data.liveCoordinates[i][1]} `)\n            }\n        }\n        matrix = numberPairArrayToMatrix(data.liveCoordinates);\n    }\n\n    const builder: string[] = []\n    builder.push(\"!Name: \" + data.name + \"\\n\")\n    if (data.description.length > 0) {\n        if (typeof(data.description) === \"string\") {\n                const lines = data.description.replace(\"\\r\", \"\").split(\"\\n\")\n                lines.forEach(line => builder.push(`!${line}\\n`))\n        } else {\n            const lines = data.description.flatMap(lines => lines.split(\"\\n\"))\n            lines.forEach(line => builder.push(`!${line}\\n`))\n        }\n    }\n    builder.push(\"!\\n\")\n    \n    const height = matrix.length;\n    const width = Math.max(...matrix.map(row => row.length))\n    for (let row = 0; row < height; row++) {\n        for (let col = 0; col < width; col++) {\n            if (col >= matrix[row].length) {\n                builder.push(\".\")\n            } else {\n                builder.push(matrix[row][col] === 0 ? \".\" : \"O\")\n            }\n        }\n        builder.push(\"\\n\")\n    }\n\n    return builder.join(\"\")\n}\n\n// --------------------------------------------------------------\n// --------------------------------------------------------------\n// --------------------------------------------------------------\n// ------------------------- READING ----------------------------\n// --------------------------------------------------------------\n// --------------------------------------------------------------\n// --------------------------------------------------------------\n\n\nexport function isPlaintextString(str: string): boolean {\n    try {\n        readPlaintextString(str);\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\n\nexport function readPlaintextString(str: string): PlaintextDecodedData {\n    if (str.length === 0) {\n        throw new Error(`[llcacodec] Attempted to pass in empty string toward Plain Text Decoder`)\n    }\n    \n    const lines = str.replace(\"\\r\", \"\").split(\"\\n\").map(line => line.trim())\n    if (lines.length === 0) {\n        throw new Error(`[llcacodec] Could not find any unique lines in plain text string \"${str}\"`)\n    }\n    \n    const contents: PlaintextDecodedData = {\n        format: \"plaintext\",\n        name: \"\",\n        description: [],\n        matrix: [],\n        liveCoordinates: []\n    }\n    \n\n    //reads header line\n    if (isNextChar(lines[0], \"!\")) {\n        const [, afterHeaderExclamation] = readChar(lines[0], \"!\")\n        if (isNextChars(afterHeaderExclamation, \"Name:\")) {\n            const [, afterNameDeclaration] = readChars(afterHeaderExclamation, \"Name:\")\n            contents.name = afterNameDeclaration.trim();\n        } else {\n            contents.name = afterHeaderExclamation.trim()\n        }\n    } else {\n        const trimmedStr = str.trim();\n        if (isPlaintextDiagram(trimmedStr)) {\n            return {\n                format: \"plaintext\",\n                name: \"\",\n                description: [],\n                matrix: readPlaintextDiagramToMatrix(trimmedStr),\n                liveCoordinates: readPlaintextDiagramToXY(trimmedStr)\n            }\n        }\n        throw new Error(`[llcacodec::readPlaintextString] attempted to read invalid plain text string ${str}. ${str} could neither be determined to be a plaintext string nor a plaintext diagram`)\n    }\n\n    //reading description lines\n    let currentLine = 1;\n    while (isNextChar(lines[currentLine], \"!\")) {\n        const [, description] = readChar(lines[currentLine], \"!\")\n        if (description.trim().length > 0) {\n            contents.description.push(description.trim())\n        }\n        currentLine++;\n    }\n\n    const diagramLines = lines.slice(currentLine).join(\"\\n\")\n    if (isPlaintextDiagram(diagramLines)) {\n        contents.liveCoordinates = readPlaintextDiagramToXY(diagramLines)\n        contents.matrix = readPlaintextDiagramToMatrix(diagramLines);\n    } else {\n        throw new Error(`[llcacodec::readPlaintextString could not read final section of Plaintext string as Plaintext diagram]`)\n    }\n    return contents\n}\n\nexport function readPlaintextDiagramToXY(str: string): [number, number][] {\n    if (!isPlaintextDiagram(str)) {\n        throw new Error(`[llcacodec::readPlaintextDiagramToXY] attempted to read invalid plaintext diagram ${str}`)\n    }\n\n    const lines = str.split(\"\\n\")\n    return lines.flatMap((line, row) => \n        line.split(\"\").map((char, col) => VALID_LIVE_CELL_CHARACTERS.some(valid => valid === char) ? [col, -row] : []).filter(point => point.length > 0) as [number, number][]\n    )\n}\n\nexport function readPlaintextDiagramToMatrix(str: string): (0 | 1)[][] {\n    if (!isPlaintextDiagram(str)) {\n        throw new Error(`[llcacodec::readPlaintextDiagramToXY] attempted to read invalid plaintext diagram ${str}`)\n    }\n\n    const lines = str.trim().replace(\"\\r\", \"\").split(\"\\n\")\n    const width = Math.max(...lines.map(line => line.length))\n    return lines.map(line => {\n        const newLine = new Array<0 | 1>(width)\n        for (let i = 0; i < width; i++) {\n            if (i >= line.length) {\n                newLine[i] = 0;\n            } else if (VALID_LIVE_CELL_CHARACTERS.some(ch => ch === line[i])) {\n                newLine[i] = 1\n            } else if (VALID_DEAD_CELL_CHARACTERS.some(ch => ch === line[i])) {\n                newLine[i] = 0\n            } else if (line[i] !== \" \" && line[i] !== \"\\r\") {\n                throw new Error(`[llcacodec::readPlaintextDiagramToMatrix Found invalid character (UTF-8 code: ${line[i].charCodeAt(0)})`)\n            }\n        }\n        return newLine\n    })\n\n\n\n}\n\n\nexport function isPlaintextDiagram(line: string): boolean {\n    return line.split(\"\").every(char => VALID_DEAD_CELL_CHARACTERS.some(ch => ch === char) || \n    VALID_LIVE_CELL_CHARACTERS.some(ch => ch === char) || \n    char === \" \" \n    || char === \"\\n\" \n    || char === \"\\r\");\n}", "import { isNextChar, isNextChars, readChar, readChars, readCrampedNumber, readNext, readNumbers } from \"../../core/strRead\"\nimport { isDigit, throws, getCellBoundingBox, numberPairArrayToMatrix  } from \"../../core/util\"\nimport { LifeRuleData, readLifeRule, isValidLifeRule, CONWAY_RULE_STRING_BS, CONWAY_LIFE_RULE_DATA, makeLifeRule, convertLifeRule } from \"../rule\";\n\ninterface HashLine {\n    id: string,\n    content: string,\n    full: string\n}\n\nexport interface RLEDecodedData {\n    format: \"rle\"\n    comments: string[],\n    name: string,\n    topleft: [number, number],\n    foundTopLeft: boolean,\n    width: number,\n    height: number,\n    ruleString: string,\n    rule: LifeRuleData,\n    liveCoordinates: [number, number][],\n    hashLines: HashLine[],\n    creationData: string\n}\n\ninterface RLEHeaderDecodedData {\n    width: number,\n    height: number,\n    ruleString: string | null,\n    rule: LifeRuleData | null,\n    full: string\n}\n\ninterface RLECommonEncodingData {\n    name?: string,\n    rule?: string | number | LifeRuleData,\n    comments?: string[],\n    creationData?: string,\n}\n\nexport interface RLEMatrixEncodingData extends RLECommonEncodingData {\n    topleft: [number, number]\n    matrix: (0 | 1)[][],\n}\n\nexport interface RLECoordinateEncodingData extends RLECommonEncodingData {\n    liveCoordinates: [number, number][]\n}\n\nconst RLE_DEAD_CELL_CHAR = \"b\"\nconst RLE_LIVE_CELL_CHAR = \"o\"\nconst RLE_NEW_LINE_CHAR = \"$\"\nconst RLE_TERMINATION_CHAR = \"!\"\nconst DIGIT_DECIMAL_CHARACTERS = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"] as const\nconst RLE_VALID_CHARACTERS = [RLE_DEAD_CELL_CHAR, RLE_LIVE_CELL_CHAR, RLE_NEW_LINE_CHAR, RLE_TERMINATION_CHAR, ...DIGIT_DECIMAL_CHARACTERS, \"\\n\", \"\\r\"] as const\n\n// --------------------------------------------------------------\n// --------------------------------------------------------------\n// --------------------------------------------------------------\n// ------------------------- READING ----------------------------\n// --------------------------------------------------------------\n// --------------------------------------------------------------\n// --------------------------------------------------------------\n\n\n\nfunction isValidRLEDataCharacter(char: string): boolean {\n    return RLE_VALID_CHARACTERS.some(validChar => validChar === char)\n}\n\ninterface ParsedRLEData {\n    liveCoordinates: [number, number][],\n    pattern: string,\n    endingIndex: number,\n    readonly topleft: [number, number]\n}\n\n/**\n * Must start \n * \n * Must end with ! or have no more data at the end at the end (please end your RLE data with a !)\n * \n * @param rleData \n */\nexport function readRLEData(rlePattern: string, topleft: [number, number] = [0, 0]): ParsedRLEData {\n    let i = 0;\n    let currRun: string[] = []\n\n    const rleData: ParsedRLEData = {\n        liveCoordinates: [],\n        pattern: \"\",\n        endingIndex: 0,\n        topleft: [...topleft] \n    }\n\n    let currCoordinate: [number, number] = [...topleft]\n\n    while (isValidRLEDataCharacter(rlePattern[i]) && i < rlePattern.length) {\n\n        if (rlePattern[i] === RLE_TERMINATION_CHAR) {\n            rleData.pattern = rlePattern.substring(0, i)\n            rleData.endingIndex = i;\n            return rleData;\n        } else if (isDigit(rlePattern[i])) {\n            currRun.push(rlePattern[i])\n        } else if (rlePattern[i] === RLE_LIVE_CELL_CHAR || rlePattern[i] === RLE_DEAD_CELL_CHAR) {\n            const runLength = currRun.length === 0 ? 1 : Number.parseInt(currRun.join(\"\"))\n            currRun = []\n            if (isNaN(runLength)) {\n                throw new Error(\"\")\n            }\n\n            if (rlePattern[i] === RLE_LIVE_CELL_CHAR) {\n                for (let j = 0; j < runLength; j++) {\n                    rleData.liveCoordinates.push([...currCoordinate])\n                    currCoordinate[0]++;\n                }\n            } else if (rlePattern[i] === RLE_DEAD_CELL_CHAR) {\n                currCoordinate[0] += runLength;\n            }\n\n        } else if (rlePattern[i] === RLE_NEW_LINE_CHAR) {\n            const runLength = currRun.length === 0 ? 1 : Number.parseInt(currRun.join(\"\"))\n            currRun = []\n            currCoordinate[0] = topleft[0]\n            currCoordinate[1] -= runLength;\n        }\n\n        i++;\n    }\n\n    if (i === rlePattern.length - 1) {\n        rleData.pattern = rlePattern\n        rleData.endingIndex = rlePattern.length - 1\n        return rleData;\n    }\n\n    throw new Error(`Unexpected ending to RLE Data. Ended at char (${rlePattern[i]} at index ${i} of ${rlePattern.length})`)\n}\n\nexport function readRLEStringHeader(headerLine: string): RLEHeaderDecodedData {\n    const trimmed = headerLine.trim();\n\n    const rleFileHeaderData: RLEHeaderDecodedData = {\n        width: 0,\n        height: 0,\n        ruleString: null,\n        rule: null,\n        full: trimmed\n    }\n\n    const [, afterXEquals] = readChars(trimmed, \"x=\")\n    const [width, afterWidth] = readCrampedNumber(afterXEquals)\n    rleFileHeaderData.width = width\n\n    const [, afterYEquals] = readChars(afterWidth, \",y=\")\n    const [height, afterHeight] = readCrampedNumber(afterYEquals)\n    rleFileHeaderData.height = height\n\n    if (isNextChars(afterHeight, \",rule=\")) {\n        const [, afterRule] = readChars(afterHeight, \",rule=\")\n        const [rule, end] = readNext(afterRule)\n        if (isValidLifeRule(rule)) {\n            rleFileHeaderData.rule = readLifeRule(rule)\n            rleFileHeaderData.ruleString = rule;\n        } else {\n            throw new Error(`Invalid Rule found in RLE Data while parsing RLE Header Line: \"${rule}\" ( passed in \"${headerLine}\") `)\n        }\n    }\n\n    return rleFileHeaderData\n}\n\nexport function isRLEString(file: string): boolean {\n    const lines = file.trim().split(\"\\n\")\n    for (let i = 0; i < lines.length; i++) {\n        if (!lines[i].trim().startsWith(\"#\") && i < lines.length - 1) {\n            return !throws(() => readRLEStringHeader(lines[i].trim()))\n        }\n    }\n\n    return false;\n}\n\n\nexport function readRLEString(file: string): RLEDecodedData {\n    const lines = file.trim().split(\"\\n\")\n    let currentLine = 0;\n\n    const rleDecodedData: RLEDecodedData = {\n        format: \"rle\",\n        comments: [],\n        name: \"\",\n        creationData: \"\",\n        topleft: [0, 0],\n        foundTopLeft: false,\n        width: 0,\n        height: 0,\n        ruleString: CONWAY_RULE_STRING_BS,\n        rule: CONWAY_LIFE_RULE_DATA(),\n        liveCoordinates: [],\n        hashLines: []\n    }\n    \n    //commented lines\n    while (isNextChar(lines[currentLine], \"#\")) {\n        const [, afterHashTag] = readChar(lines[currentLine], \"#\")\n        const [id, afterID] = readChar(afterHashTag)\n        const content = afterID.trim()\n\n        if (content.length > 0) {\n\n            if (id === \"C\" || id === \"c\") {\n                rleDecodedData.comments.push(content)\n            } else if (id === \"N\") {\n                rleDecodedData.name = content\n            } else if (id === \"O\") {\n                rleDecodedData.creationData = content\n            } else if (id === \"P\" || id === \"R\") {\n                const [[x, y]] = readNumbers(afterID, 2)\n                rleDecodedData.topleft = [x, y]\n                rleDecodedData.foundTopLeft = true\n            } else if (id === \"r\") {\n                rleDecodedData.ruleString = content\n                rleDecodedData.rule = readLifeRule(content)\n            }\n\n        }\n\n        rleDecodedData.hashLines.push({\n            content: afterID.trim(),\n            id: id,\n            full: lines[currentLine].trim()\n        })\n\n        currentLine++;\n    }\n\n    //header line\n    const headerLineData = readRLEStringHeader(lines[currentLine])\n    rleDecodedData.width = headerLineData.width;\n    rleDecodedData.height = headerLineData.height\n    if (headerLineData.ruleString !== null && headerLineData.rule !== null) {\n        rleDecodedData.rule = headerLineData.rule\n        rleDecodedData.ruleString = headerLineData.ruleString\n    }\n    \n    //rle encoded data\n    \n    currentLine++;\n    const afterHeader = lines.slice(currentLine).join(\"\\n\") \n    const data = readRLEData(afterHeader, rleDecodedData.topleft)\n\n    rleDecodedData.liveCoordinates = data.liveCoordinates\n    if (data.endingIndex + 1 !== afterHeader.length - 1) {\n        const afterRLEData = afterHeader.substring(data.endingIndex + 1)\n        const linesAfterRLEData = afterRLEData.split(\"\\n\")\n        rleDecodedData.comments.push(...linesAfterRLEData.map(line => line.trim()).filter(line => line.length > 0))\n    }\n\n\n    //Everything after this is considered a comment\n\n    return rleDecodedData\n}\n\n// --------------------------------------------------------------\n// --------------------------------------------------------------\n// --------------------------------------------------------------\n// ------------------------- WRITING ----------------------------\n// --------------------------------------------------------------\n// --------------------------------------------------------------\n// --------------------------------------------------------------\n\nfunction rleEncode(char: string, count: number): string {\n    if (char.length !== 1) {\n        throw new Error(`[llcacodec] Cannot RLE Encode character ${char} with a length of ${char.length}. Length of character must be 1`)\n    }\n    if (count < 0 || !Number.isInteger(count)) {\n        throw new Error(`[llcacodec] Cannot RLE Encode character ${char} with a count of ${count}. The count must be an integer greater than or equal to 1`)\n    }\n\n    if (count === 0) {\n        return \"\"\n    } else if (count === 1) {\n        return char;\n    } else {\n        return `${count}${char}`\n    }\n}\n\nfunction writeRLEDataM(matrix: (0 | 1)[][]) {\n    const encoding: string[] = []\n\n        for (let row = 0; row < matrix.length; row++) {\n            let anyInLine: boolean = false;\n            let currentLine: string[] = []\n            for (let col = 0; col < matrix[row].length; col++) {\n                if (matrix[row][col] === 1) {\n                    anyInLine = true;\n                    currentLine.push(RLE_LIVE_CELL_CHAR)\n                } else if (matrix[row][col] === 0) {\n                    currentLine.push(RLE_DEAD_CELL_CHAR)\n                } else {\n                    throw new Error(`[llcacodec] Cannot write RLE data where matrix has values that are not 0 or 1 ( got ${matrix[row][col]} at row ${row} and col ${col}) `)\n                }\n            }\n\n            if (anyInLine) {\n                encoding.push(...currentLine);\n            }\n            encoding.push(RLE_NEW_LINE_CHAR)\n        }\n        encoding.push(RLE_TERMINATION_CHAR)\n        const rleEncodedBuffer: string[] = []\n\n        let currentChar: string = encoding[0]\n        let currentCharCount: number = 1\n        for (let i = 1; i < encoding.length; i++) {\n            if (encoding[i] === currentChar) {\n                currentCharCount++;\n            } else {\n                rleEncodedBuffer.push(rleEncode(currentChar, currentCharCount))\n                currentChar = encoding[i]\n                currentCharCount = 1\n            }\n        }\n        rleEncodedBuffer.push(RLE_TERMINATION_CHAR)\n        return rleEncodedBuffer.join(\"\")\n}\n\nfunction writeRLEDataC(liveCoordinates: [number, number][]) {\n    if (liveCoordinates.length === 0) {\n        return \"\"\n    }\n\n    return writeRLEDataM(numberPairArrayToMatrix(liveCoordinates))\n}\n\nconst MAX_RLE_CHARACTER_LINE_WIDTH = 70\n\nexport function writeRLEString(data: RLEMatrixEncodingData | RLECoordinateEncodingData) {\n    const comments: string[] = data.comments !== undefined ? [...data.comments] : []\n    const creationData: string = data.creationData !== undefined ? data.creationData : \"\"\n    const name: string = data.name !== undefined ? data.name : \"\"\n    \n    let bsRule: string = CONWAY_RULE_STRING_BS\n    if (data.rule !== undefined) { \n        if (typeof(data.rule) === \"string\" || typeof(data.rule) === \"number\") {\n            bsRule = convertLifeRule(data.rule, \"b/s\")\n        } else {\n            bsRule = makeLifeRule(data.rule, \"b/s\")\n        }\n    }\n    \n    let topleft = [0, 0]\n    let width = 0;\n    let height = 0;\n    if (\"matrix\" in data) {\n        width = Math.max(...data.matrix.map(row => row.length))\n        height = data.matrix.length;\n        topleft = data.topleft;\n    } else if (\"liveCoordinates\" in data) {\n        const bounds = getCellBoundingBox(data.liveCoordinates);\n        width = bounds.width;\n        height = bounds.height;\n        topleft = [bounds.x, bounds.y]\n    }\n\n    const lineBuilder: string[] = []\n    \n    if (name !== \"\") {\n        lineBuilder.push(`#N ${name}`)\n    }\n    if (creationData !== \"\") {\n        lineBuilder.push(`#O ${creationData}`)\n    }\n\n    const trimmedComments = []\n    for (let i = 0; i < comments.length; i++) {\n        for (let j = 0; j < comments[i].length; j += MAX_RLE_CHARACTER_LINE_WIDTH) {\n            trimmedComments.push(comments[i].substring(j, Math.min(comments[i].length, j + MAX_RLE_CHARACTER_LINE_WIDTH)))\n        }\n    }\n    trimmedComments.forEach(trimmedComments => lineBuilder.push(`#C ${trimmedComments}`))\n\n    lineBuilder.push(`x = ${width}, y = ${height}, rule = ${bsRule}`)\n    lineBuilder.push(\"matrix\" in data ? writeRLEDataM(data.matrix) : writeRLEDataC(data.liveCoordinates))\n    return lineBuilder.join(\"\\n\")\n}", "// Life 1.05 File Format Spec: https://conwaylife.com/wiki/Life_1.05\n\nimport { numberPairArrayToMatrix, uniqueNumberPairArray } from \"../../core/util\";\nimport { isNextChar, isNextChars, readChar, readChars, readIntegers, readLine } from \"../../core/strRead\";\nimport { CONWAY_LIFE_RULE_DATA, CONWAY_RULE_STRING_SB, readLifeRule } from \"../rule\";\n\nconst LIFE_105_HEADER = \"#Life 1.05\" as const\nconst MAX_DESCRIPTION_LINE_COUNT = 22\nconst LIFE_105_MAX_LINE_LENGTH = 80\n\nconst Life105FileExtensions = [\".lif\", \".life\"] as const;\n\ntype LifeRuleData = { birth: number[], survival: number[] }\n\ninterface Life105Config {\n  descriptions: string | string[],\n  rule: string | LifeRuleData | number | \"N#\"\n}\n\ninterface HashLine {\n    id: string,\n    content: string,\n    full: string\n}\n\ninterface Life105CellBlock {\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    pattern: (0 | 1)[][]\n    liveCoordinates: [number, number][]\n}\n\nexport interface Life105DecodedData {\n    format: \"life 1.05\"\n    cellBlocks: Life105CellBlock[]\n    liveCoordinates: [number, number][]\n    descriptions: string[],\n    rule: string | null,\n    parsedRule: LifeRuleData | null,\n    hashLines: HashLine[]\n}\n\nconst LIFE_105_DEAD_CHAR = \".\"\nconst LIFE_105_ALIVE_CHAR = \"*\"\n\nfunction isLife105CellBlock(data: string): boolean {\n    if (!isNextChars(data, \"#P\")) {\n        return false;\n    }\n    const [pointLine, afterPointLine] = readLine(data)\n    const [, afterPointDeclaration] = readChars(pointLine, \"#P\")\n\n    const [[x, y]] = readIntegers(afterPointDeclaration, 2)\n    \n    const trimmedPatternLines = afterPointLine.split(\"\\n\").map(line => line.trim())\n    for (let i = 0; i < trimmedPatternLines.length; i++) {\n        for (let j = 0; j < trimmedPatternLines[i].length; j++) {\n            if ( !( trimmedPatternLines[i][j] === LIFE_105_DEAD_CHAR || trimmedPatternLines[i][j] === LIFE_105_ALIVE_CHAR ) ) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\nfunction readLife105CellBlock(data: string): Life105CellBlock {\n    const trimmedLines = data.split(\"\\n\").map(line => line.trim())\n    const pointLine = trimmedLines[0]\n    const [, afterPointDeclaration] = readChars(pointLine, \"#P\")\n    const [[x, readY]] = readIntegers(afterPointDeclaration, 2)\n    const y = -readY; // positive y is down for life 1.05, so I flip it for compatibility with llcacodec where positive y is up\n\n    let i = 1;\n    const liveCoordinates: [number, number][] = []\n    while (i < trimmedLines.length && !isNextChars(trimmedLines[i], \"#P\")) {\n        for (let j = 0; j < trimmedLines[i].length; j++) {\n            if (trimmedLines[i][j] === LIFE_105_ALIVE_CHAR) {\n                liveCoordinates.push([x + j,  y - (i - 1)]) \n            } \n        }\n        i++;\n    }\n\n    const matrix = numberPairArrayToMatrix(liveCoordinates)\n\n    return {\n        x: x,\n        y: y,\n        width: matrix.length !== 0 ? matrix[0].length : 0,\n        height: matrix.length,\n        pattern: matrix,\n        liveCoordinates: liveCoordinates\n    }\n}\n\nfunction extractLife105CellBlockStrings(data: string): string[] {\n    const lines = data.trim().split(\"\\n\")\n    const cellBlockStrings: string[] = [];\n\n    let cellBlockStart = -1;\n    for (let i = 0; i < lines.length; i++) {\n        if (isNextChars(lines[i].trim(), \"#P\")) {\n            if (cellBlockStart !== -1) {\n                cellBlockStrings.push(lines.slice(cellBlockStart, i).join(\"\\n\"));\n            }\n            cellBlockStart = i;\n        }\n    }\n\n    if (cellBlockStart !== -1) {\n        cellBlockStrings.push(lines.slice(cellBlockStart, lines.length).join(\"\\n\"));\n    }\n\n    return cellBlockStrings\n}\n \nexport function isLife105String(file: string): boolean {\n    return file.trim().startsWith(LIFE_105_HEADER)\n}\n\nexport function readLife105String(file: string): Life105DecodedData {\n    file = file.replace(\"\\r\", \"\")\n\n    const life105StringData: Life105DecodedData = {\n        format: \"life 1.05\",\n        cellBlocks: [],\n        liveCoordinates: [],\n        descriptions: [],\n        rule: null,\n        parsedRule: null,\n        hashLines: []\n    }\n\n    const lines = file.split(\"\\n\")\n    const headerLine = lines[0]\n    if (!headerLine.trim().startsWith(LIFE_105_HEADER)) {\n        throw new Error(`[llcacodec::readLife105String given Life105String does not begin with the required Life 1.05 header \"#Life 1.05\"]`)\n    }\n\n    let currentLineIndex = 1;\n\n    while (isNextChar(lines[currentLineIndex], \"#\")) {\n        const [, afterHash] = readChar(lines[currentLineIndex], \"#\")\n        const [id, afterID] = readChar(afterHash)\n        const trimmedContent = afterID.trim();\n\n        if (id === \"D\") {\n            life105StringData.descriptions.push(trimmedContent)\n        } else if (id === \"R\") {\n            life105StringData.rule = trimmedContent\n            life105StringData.parsedRule = readLifeRule(trimmedContent)\n        } else if (id === \"N\") {\n            life105StringData.rule = CONWAY_RULE_STRING_SB\n            life105StringData.parsedRule = CONWAY_LIFE_RULE_DATA()\n        } else if (id === \"P\") { // encountered beginning of Cell Block Data\n            break;\n        }\n\n        life105StringData.hashLines.push({\n            id: id,\n            content: trimmedContent,\n            full: lines[currentLineIndex].trim()\n        })\n\n        currentLineIndex++\n    }\n\n    const cellBlockStrings: string[] = extractLife105CellBlockStrings(lines.slice(currentLineIndex).join(\"\\n\"));\n\n    for (let i = 0; i < cellBlockStrings.length; i++) {\n        const cellBlock = readLife105CellBlock(cellBlockStrings[i])\n        life105StringData.cellBlocks.push(cellBlock)\n        life105StringData.liveCoordinates.push(...cellBlock.liveCoordinates)\n    }\n\n    life105StringData.liveCoordinates = uniqueNumberPairArray(life105StringData.liveCoordinates)\n\n    return life105StringData\n}", "\n\nimport { readLife106String, isLife106String, writeLife106String, Life106DecodedData, Life106EncodingData } from \"./life106\"\nimport { readPlaintextString, isPlaintextString, PlaintextDecodedData, PlaintextMatrixEncodingData, PlaintextCoordinateEncodingData, writePlaintextString } from \"./plaintext\"\nimport { RLECoordinateEncodingData, RLEDecodedData, RLEMatrixEncodingData, isRLEString, readRLEString, writeRLEString } from \"./rle\"\nimport { Life105DecodedData, isLife105String, readLife105String } from \"./life105\"\n\nexport type SupportedLifeLikeReadFileFormats = \"life 1.06\" | \"life 1.05\" | \"plaintext\" | \"rle\"\nexport type SupportedLifeLikeWriteFileFormats = \"life 1.06\" | \"plaintext\" | \"rle\"\n\n/**\n * Read a life string\n * \n * A life string can be in either one of these formats. \n * \n * [Life 1.05](https://conwaylife.com/wiki/Life_1.05):\n * represented by the string \"life 1.05\"\n * \n * [Life 1.06](https://conwaylife.com/wiki/Life_1.06):\n * represented by the string \"life 1.06\"\n * \n * [Plaintext](https://conwaylife.com/wiki/Plaintext):\n * represented by the string \"plaintext\"\n * \n * [Run-Length Encoded (RLE)](https://conwaylife.com/wiki/Run_Length_Encoded).\n * represented by the string \"rle\"\n * \n * @note Usually these files are generated by a Life-Like program, such as Golly or XLife,\n * or by a library such as llcacodec. However, they can be written by hand if you so please.\n * \n * The output of the given data object is based on which one of the formats is parsed. However, all returned data\n * is guaranteed to have 2 keys: \"format\" and \"liveCoordinates\". \n * \n * The parsed format can be found with the \"format\" key,\n * which will either have a value of \"plaintext\", \"life 1.06\", \"life 1.05\", or \"rle\" corresponding with the given life string's format.\n * The layout of the parsed data can then be determined by finding the value of the \"format\" key.\n * \n * \"liveCoordinates\" will be a 2D vector array in [x, y] format where each entry represents a live cell.\n * x and y are guaranteed to be integers.\n * x is positive to the right and negative approaching the left, and y is positive approaching north and\n * negative approaching south. This may be good to take note of if your program assumes that positive \n * y approaches south, such as in a \"row\" and \"column\" layout.\n * \n * The particulars of each data format is out of the scope of this little docstring, \n * and can be found in DOCUMENTATION.md in the llcacodec repository. This documentation\n * could also be found online [here](https://www.github.com/cobyj33/llcacodec/blob/master/DOCUMENTATION.md)\n * \n * @param data The life string to parse for data\n * @param format Optional parameter. Defaults to \"\" if no parameter is passed. This is the format\n * used by readLifeString to parse the data. format can equal either \"life 1.06\", \"life 1.05\",\n * \"plaintext\", \"rle\", or \"\". If format equals \"\", then readLifeString will attempt to detect\n * the format of the provided data. If undefined is passed, an error is thrown\n * \n * @throws 1. If there is an error parsing the given life string in a given format.  \n * 2. If there is an error finding the life string's format.  \n * 3. If the passed format is undefined.  \n */\nexport function readLifeString(data: string, format: \"plaintext\"): PlaintextDecodedData\nexport function readLifeString(data: string, format: \"life 1.06\"): Life106DecodedData\nexport function readLifeString(data: string, format: \"rle\"): RLEDecodedData\nexport function readLifeString(data: string, format: \"life 1.05\"): Life105DecodedData\nexport function readLifeString(data: string): Life106DecodedData | PlaintextDecodedData | RLEDecodedData | Life105DecodedData\nexport function readLifeString(data: string, format: SupportedLifeLikeReadFileFormats | \"\" = \"\"): Life106DecodedData | PlaintextDecodedData | RLEDecodedData | Life105DecodedData {\n    if (data.length === 0) {\n        throw new Error(\"[llcacodec::readLifeString] Cannot read empty life string.\");\n    }\n    if (format === undefined) {\n        throw new Error(\"[llcacodec]: Cannot parse undefined life file\")\n    }\n\n    const foundFormat = format === \"\" ? getLifeStringFormat(data) : format;\n    switch (foundFormat) {\n        case \"plaintext\": return readPlaintextString(data);\n        case \"life 1.06\": return readLife106String(data);\n        case \"rle\": return readRLEString(data);\n        case \"life 1.05\": return readLife105String(data);\n        case \"\": throw new Error(`[llcacodecjs] Could not read life file: matching life file format could not be found`) \n    }\n}\n\n/**\n * Assert whether a life string conforms to a given format\n * \n * Note that just because isLifeStringFormat returns true does NOT mean that readLifeString will not throw an error when called with the given life string.\n * isLifeStringFormat does not confirm if the passed data is valid. It only tries to detect if the given life string\n * conforms to a format by searching for required headers and sequences in the string.\n * \n * @param data The life string to test\n * @param format The format to test conformity against the given life string with.\n * Can either be \"plaintext\", \"life 1.05\", \"life 1.06\", or \"plaintext\" \n * @returns Whether the given life string conforms with the given format\n */\nexport function isLifeStringFormat(data: string, format: SupportedLifeLikeReadFileFormats): boolean {\n    if (data.length === 0) {\n        return false;\n    }\n\n    switch (format) {\n        case \"life 1.06\": return isLife106String(data);\n        case \"life 1.05\": return isLife105String(data);\n        case \"plaintext\": return isPlaintextString(data);\n        case \"rle\": return isRLEString(data);\n    }\n}\n\n/** Detect the format of a life string\n * \n * Note that just because getLifeStringFormat detects a file format does NOT mean that readLifeString will not throw an error\n * when called with the given life string. getLifeStringFormat does not confirm if the passed data is valid.\n * It only tries to detect the given life string's format by searching for required headers and sequences in the string.\n * \n * @param data The life string to get the format of\n * @returns Either \"life 1.06\", \"life 1.05\", \"rle\", or \"plaintext\" on the finding\n * of a successful format, and an empty string when no format could be found.\n */\nexport function getLifeStringFormat(data: string): SupportedLifeLikeReadFileFormats | \"\" {\n    if (data.length === 0) {\n        return \"\"\n    }\n    \n    // Note how the tests are ordered. They are ordered from the most simple to identify\n    // to the least simple to identify. Life 1.06 and Life 1.05 can simply be identified by\n    // if their file begins with the appropriate header data. isRLEString is identified by the existence of \n    // a header, although it may not be at the beginning of the file. Finally, Plaintext is identified by simply\n    // checking if the file parses correctly\n\n    if (isLife106String(data)) {\n        return \"life 1.06\"\n    } else if (isLife105String(data)) {\n        return \"life 1.05\"\n    } else if (isRLEString(data)) {\n        return \"rle\"\n    } else if (isPlaintextString(data)) {\n        return \"plaintext\"\n    }\n    \n    return \"\"\n}\n\nexport type FileFormatEncodingData = ( Life106EncodingData & { format: \"life 1.06\"} ) | \n( PlaintextMatrixEncodingData & { format: \"plaintext\"} ) | \n( PlaintextCoordinateEncodingData & { format: \"plaintext\"} ) |\n( RLEMatrixEncodingData & { format: \"rle\" } ) |\n( RLECoordinateEncodingData & { format: \"rle\" })\n\n/**\n * Write a Life String, keeping the passed data in a portable string format\n * \n * writeLifeString can write in either one of these formats:\n * \n * [Life 1.06](https://conwaylife.com/wiki/Life_1.06):\n * represented by the presence of { format: \"life 1.06\" } in the given structured data\n * \n * [Plaintext](https://conwaylife.com/wiki/Plaintext):\n * represented by the presence of { format: \"plaintext\" } in the given structured data\n * \n * [Run-Length Encoded (RLE)](https://conwaylife.com/wiki/Run_Length_Encoded):\n * represented by the presence of { format: \"rle\" } in the given structured data\n * \n * Given all of these formats, rle will likely be the most compressed and desired\n * format the large majority of the time. Generally, it is much better to represent\n * any semi-large or large pattern, but it is less straight-forward for humans to read\n * if that is desired.\n * \n * Plaintext will be a little larger, but should generally not be used for patterns with a bounding box with a width\n * greater than 80 cells. Plaintext, however, could be desired for smaller patterns because of\n * the human-readability of the pattern's diagram.\n * \n * Life 1.06 is also viable for smaller patterns. However, since Life 1.06 lists every single\n * coordinate without any compression, Life 1.06 could make for larger files as well.\n * \n * The particulars of each data format is out of the scope of this little docstring, \n * and can be found in DOCUMENTATION.md in the llcacodec repository. This documentation\n * could also be found online [here](https://www.github.com/cobyj33/llcacodec/blob/master/DOCUMENTATION.md)\n * \n * @param data The structured data to use when creating the life string\n * @returns A life string containing the passed in compiled data.\n */\nexport function writeLifeString(data: FileFormatEncodingData): string {\n    switch (data.format) {\n        case \"life 1.06\": return writeLife106String(data);\n        case \"plaintext\": return writePlaintextString(data);\n        case \"rle\": return writeRLEString(data)\n    }\n}\n\nexport default {\n    readLifeString,\n    writeLifeString,\n    isLifeStringFormat,\n    getLifeStringFormat\n}", "/**\n * @file api.ts\n * @description The public API for the llcacodec library\n * @author Jacoby Johnson\n * @version 0.1.5\n * @date April 11th, 2023\n * @license MIT\n */\n\nimport { readLifeRule, makeLifeRule, isValidLifeRule, getLifeRuleFormat, convertLifeRule } from \"./formats/rule\"\nimport { readLifeString, writeLifeString, isLifeStringFormat, getLifeStringFormat } from \"./formats/file\"\n\nexport { LifeRuleData, CONWAY_LIFE_RULE_DATA } from \"./formats/rule/ruleData\"\nexport { readLifeRule, makeLifeRule, isValidLifeRule, getLifeRuleFormat, convertLifeRule } from \"./formats/rule\"\nexport { readLifeString, writeLifeString, isLifeStringFormat, getLifeStringFormat, SupportedLifeLikeReadFileFormats, SupportedLifeLikeWriteFileFormats, FileFormatEncodingData } from \"./formats/file\"\n\nexport default {\n    readLifeString,\n    writeLifeString,\n    isLifeStringFormat,\n    getLifeStringFormat,\n    makeLifeRule, \n    isValidLifeRule,\n    getLifeRuleFormat,\n    readLifeRule,\n    convertLifeRule\n}"],
  "mappings": "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",
  "names": ["CONWAY_LIFE_RULE_DATA", "getLifeRuleDataError", "birth", "survival", "num", "isValidLifeRuleData", "lifeRuleData", "getLifeRuleDataError", "CONWAY_RULE_STRING_BS", "getBSLifeStringError", "lifeString", "sides", "birthNums", "numChar", "survivalNums", "num", "isValidBSLifeString", "makeBSLifeString", "lifeRuleData", "birth", "survival", "isValidLifeRuleData", "a", "b", "getLifeRuleDataError", "readBSRuleString", "lifeData", "CONWAY_RULE_STRING_SB", "getSBLifeStringError", "lifeString", "sides", "survivalNums", "birthNums", "numChar", "num", "isValidSBLifeString", "makeSBLifeString", "lifeRuleData", "birth", "survival", "isValidLifeRuleData", "a", "b", "getLifeRuleDataError", "readSBRuleString", "digit", "MAX_LIFE_INTEGER", "getLifeRuleIntegerError", "lifeInteger", "MAX_LIFE_INTEGER", "isValidLifeRuleInteger", "readLifeRuleInteger", "birthRules", "survivalRules", "lifeRuleData", "makeLifeRuleInteger", "isValidLifeRuleData", "rule", "birth", "survival", "ruleVal", "getLifeRuleDataError", "Set2D", "values", "value", "total", "set", "arr", "i", "pair", "callbackfn", "first", "second", "_a", "_b", "tuples", "tuple", "others", "other", "entry", "throws", "action", "e", "ASCII_CHAR_CODE_0", "ASCII_CHAR_CODE_9", "isDigit", "digit", "isNumericString", "num", "isIntegerString", "num", "i", "isDigit", "getCellBoundingBox", "positions", "minY", "maxY", "minX", "maxX", "i", "numberPairArrayToMatrix", "bounds", "matrix", "position", "isError", "getErrorMessage", "uniqueNumberPairArray", "arr", "set2D", "Set2D", "output", "i", "isValidLifeRule", "rule", "format", "foundFormat", "getLifeRuleFormat", "isValidLifeRuleInteger", "isValidBSLifeString", "isValidSBLifeString", "readLifeRule", "readLifeRuleInteger", "readBSRuleString", "readSBRuleString", "makeLifeRule", "lifeRuleData", "makeBSLifeString", "makeSBLifeString", "makeLifeRuleInteger", "e", "getErrorMessage", "convertLifeRule", "original", "dstFormat", "LIFE_106_HEADER", "isLife106String", "str", "LIFE_106_HEADER", "writeLife106String", "data", "builder", "dupSet", "Set2D", "i", "x", "y", "readLife106String", "output", "set2D", "lines", "ended", "nums", "val", "isIntegerString", "isNextChar", "data", "char", "index", "readChar", "readChars", "charOrCount", "charsToRead", "remainingString", "afterChar", "isNextChars", "chars", "dataIndex", "charsIndex", "readNumber", "data", "numstr", "stream", "readNext", "isNumericString", "num", "readNumbers", "data", "numOfNums", "numbers", "remaining", "number", "afterRead", "readNumber", "readIntegers", "numOfIntegers", "stream", "num", "index", "pair", "readCrampedNumber", "hitPoint", "i", "numchars", "char", "isDigit", "numstr", "isNumericString", "readNext", "data", "index", "startIndex", "VALID_DEAD_CELL_CHARACTERS", "VALID_LIVE_CELL_CHARACTERS", "writePlaintextString", "data", "matrix", "i", "numberPairArrayToMatrix", "builder", "line", "lines", "height", "width", "row", "col", "isPlaintextString", "str", "readPlaintextString", "e", "contents", "isNextChar", "afterHeaderExclamation", "readChar", "isNextChars", "afterNameDeclaration", "readChars", "trimmedStr", "isPlaintextDiagram", "readPlaintextDiagramToMatrix", "readPlaintextDiagramToXY", "currentLine", "description", "diagramLines", "char", "VALID_LIVE_CELL_CHARACTERS", "valid", "point", "newLine", "ch", "VALID_DEAD_CELL_CHARACTERS", "RLE_DEAD_CELL_CHAR", "RLE_LIVE_CELL_CHAR", "RLE_NEW_LINE_CHAR", "RLE_TERMINATION_CHAR", "DIGIT_DECIMAL_CHARACTERS", "RLE_VALID_CHARACTERS", "isValidRLEDataCharacter", "char", "validChar", "readRLEData", "rlePattern", "topleft", "i", "currRun", "rleData", "currCoordinate", "isDigit", "runLength", "j", "readRLEStringHeader", "headerLine", "trimmed", "rleFileHeaderData", "afterXEquals", "readChars", "width", "afterWidth", "readCrampedNumber", "afterYEquals", "height", "afterHeight", "isNextChars", "afterRule", "rule", "end", "readNext", "isValidLifeRule", "readLifeRule", "isRLEString", "file", "lines", "throws", "readRLEString", "currentLine", "rleDecodedData", "CONWAY_RULE_STRING_BS", "CONWAY_LIFE_RULE_DATA", "isNextChar", "afterHashTag", "readChar", "id", "afterID", "content", "x", "y", "readNumbers", "headerLineData", "afterHeader", "data", "linesAfterRLEData", "line", "rleEncode", "count", "writeRLEDataM", "matrix", "encoding", "row", "anyInLine", "col", "rleEncodedBuffer", "currentChar", "currentCharCount", "writeRLEDataC", "liveCoordinates", "numberPairArrayToMatrix", "MAX_RLE_CHARACTER_LINE_WIDTH", "writeRLEString", "comments", "creationData", "name", "bsRule", "convertLifeRule", "makeLifeRule", "bounds", "getCellBoundingBox", "lineBuilder", "trimmedComments", "LIFE_105_HEADER", "LIFE_105_ALIVE_CHAR", "readLife105CellBlock", "data", "trimmedLines", "line", "pointLine", "afterPointDeclaration", "readChars", "x", "readY", "readIntegers", "y", "i", "liveCoordinates", "isNextChars", "j", "LIFE_105_ALIVE_CHAR", "matrix", "numberPairArrayToMatrix", "extractLife105CellBlockStrings", "lines", "cellBlockStrings", "cellBlockStart", "isLife105String", "file", "LIFE_105_HEADER", "readLife105String", "life105StringData", "currentLineIndex", "isNextChar", "afterHash", "readChar", "id", "afterID", "trimmedContent", "readLifeRule", "CONWAY_RULE_STRING_SB", "CONWAY_LIFE_RULE_DATA", "cellBlock", "uniqueNumberPairArray", "readLifeString", "data", "format", "getLifeStringFormat", "readPlaintextString", "readLife106String", "readRLEString", "readLife105String", "isLifeStringFormat", "isLife106String", "isLife105String", "isPlaintextString", "isRLEString", "writeLifeString", "writeLife106String", "writePlaintextString", "writeRLEString", "api_default", "readLifeString", "writeLifeString", "isLifeStringFormat", "getLifeStringFormat", "makeLifeRule", "isValidLifeRule", "getLifeRuleFormat", "readLifeRule", "convertLifeRule"]
}
